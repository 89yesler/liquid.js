// Generated by CoffeeScript 1.6.2
(function() {
  var AssignTag, CacheTag, CaptureTag, CommentTag, Liquid, arrayClear, arrayFirst, arrayFlatten, arrayHasItem, arrayIndexOf, arrayLast, arrayMap, escape_str, objectDefaults, objectExtend, objectHasKey, objectHasValue, stringCapitalize, stringTrim, truncate_words, type, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Liquid = {
    author: "Matt McCray",
    version: "2.0.1",
    readTemplateFile: function(path) {
      throw new Error("This liquid context does not allow includes.");
    },
    registerFilters: function(filters) {
      return Liquid.Template.registerFilters(filters);
    },
    parse: function(src) {
      return Liquid.Template.parse(src);
    }
  };

  if (typeof window !== "undefined" && window !== null) {
    window.Liquid = Liquid;
  } else if (typeof module !== "undefined" && module !== null) {
    module.exports = Liquid;
  }

  type = (function() {
    var classToType, elemParser, name, toStr, _i, _len, _ref;

    toStr = Object.prototype.toString;
    elemParser = /\[object HTML(.*)\]/;
    classToType = {};
    _ref = "Boolean Number String Function Array Date RegExp Undefined Null NodeList".split(" ");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    return function(obj) {
      var found, strType;

      strType = toStr.call(obj);
      if (found = classToType[strType]) {
        return found;
      } else if (found = strType.match(elemParser)) {
        return found[1].toLowerCase();
      } else {
        return "object";
      }
    };
  })();

  objectHasKey = function(object, key) {
    return (key in object);
  };

  objectHasValue = function(object, targetValue) {
    var key, value;

    for (key in object) {
      value = object[key];
      if (value === targetValue) {
        return true;
      }
    }
    return false;
  };

  objectExtend = function(object) {
    var key, source, value, _i, _len, _ref;

    _ref = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      source = _ref[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          object[key] = value;
        }
      }
    }
    return object;
  };

  objectDefaults = function(object) {
    var key, source, value, _i, _len, _ref;

    _ref = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      source = _ref[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          if (object[key] == null) {
            object[key] = value;
          } else if (type(object[key]) === 'object') {
            object[key] = objectDefaults({}, object[key], value);
          }
        }
      }
    }
    return object;
  };

  arrayMap = (function() {
    if (Array.prototype.map != null) {
      return function(array, fn, ctx) {
        return array.map(fn, ctx);
      };
    } else {
      return function(array, fn, ctx) {
        var i, item, results, _i, _len;

        results = [];
        for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
          item = array[i];
          results.push(fn.call(ctx, item, i, ctx));
        }
        return results;
      };
    }
  })();

  arrayFlatten = function(array) {
    var item, new_array, sub_array, _i, _len;

    new_array = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (type(item) === 'array') {
        sub_array = arrayFlatten(item);
        new_array = new_array.concat(sub_array);
      } else {
        new_array.push(item);
      }
    }
    return new_array;
  };

  arrayIndexOf = function(array, targetItem) {
    var i, item, _i, _len;

    if (array.indexOf != null) {
      return array.indexOf(targetItem);
    } else {
      for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
        item = array[i];
        if (item === targetItem) {
          return i;
        }
      }
      return -1;
    }
  };

  arrayHasItem = function(array, targetItem) {
    return arrayIndexOf(array, targetItem) > -1;
  };

  arrayClear = function(array) {
    return array.length = 0;
  };

  arrayFirst = function(array) {
    return array[0];
  };

  arrayLast = function(array) {
    return array[array.length - 1];
  };

  stringTrim = (function() {
    if (String.prototype.trim != null) {
      return function(str) {
        return str.trim();
      };
    } else {
      return function(str) {
        return str.replace(stringTrim.RE_START, '').replace(stringTrim.RE_END, '');
      };
    }
  })();

  stringTrim.RE_START = /^\s+/;

  stringTrim.RE_END = /^\s+$/;

  stringCapitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();
  };

  Liquid.Tag = (function() {
    function Tag(tagName, markup, tokens) {
      var _ref;

      this.tagName = tagName;
      this.markup = markup;
      if ((_ref = this.nodelist) == null) {
        this.nodelist = [];
      }
      this.parse(tokens);
    }

    Tag.prototype.parse = function(tokens) {};

    Tag.prototype.render = function(context) {
      return "";
    };

    return Tag;

  })();

  Liquid.Block = (function(_super) {
    var TAG_OPEN, TAG_PARTS, VAR_OPEN, VAR_PARTS;

    __extends(Block, _super);

    TAG_OPEN = /^\{\%/;

    TAG_PARTS = /^\{\%\s*(\w+)\s*(.*)?\%\}$/;

    VAR_OPEN = /^\{\{/;

    VAR_PARTS = /^\{\{(.*)\}\}$/;

    function Block(tagName, markup, tokens) {
      this.blockName = tagName;
      this.blockDelimiter = "end" + this.blockName;
      Block.__super__.constructor.call(this, tagName, markup, tokens);
    }

    Block.prototype.parse = function(tokens) {
      var content, tag, tag_parts, token, _, _ref;

      if ((_ref = this.nodelist) == null) {
        this.nodelist = [];
      }
      token = tokens.shift();
      tokens.push('');
      while (tokens.length) {
        if (TAG_OPEN.test(token)) {
          tag_parts = token.match(TAG_PARTS);
          if (tag_parts == null) {
            throw new Error("Tag '" + token + "' was not properly terminated with '%}'");
          }
          _ = tag_parts[0], tag = tag_parts[1], content = tag_parts[2];
          if (tag === this.blockDelimiter) {
            return this.endTag();
          }
          if (objectHasKey(Liquid.Template.tags, tag)) {
            this.nodelist.push(new Liquid.Template.tags[tag](tag, content, tokens));
          } else {
            this.unknownTag(tag, content, tokens);
          }
        } else if (VAR_OPEN.test(token)) {
          this.nodelist.push(this.createVariable(token));
        } else {
          this.nodelist.push(token);
        }
        token = tokens.shift();
      }
    };

    Block.prototype.endTag = function() {};

    Block.prototype.unknownTag = function(tag, params, tokens) {
      var msg;

      msg = (function() {
        switch (tag) {
          case 'else':
            return "" + this.blockName + " tag does not expect else tag";
          case 'end':
            return "'end' is not a valid delimiter for " + this.blockName + " tags. use " + this.blockDelimiter;
          default:
            return "Unknown tag: " + tag;
        }
      }).call(this);
      throw new Error(msg);
    };

    Block.prototype.createVariable = function(token) {
      var match;

      match = token.match(VAR_PARTS);
      if (match != null) {
        return new Liquid.Variable(match[1]);
      } else {
        throw new Error("Variable '" + token + "' was not properly terminated with: }}");
      }
    };

    Block.prototype.render = function(context) {
      return this.renderAll(this.nodelist, context);
    };

    Block.prototype.renderAll = function(list, context) {
      var content, e, output, token, _i, _len;

      if (list == null) {
        list = [];
      }
      if (context == null) {
        context = {};
      }
      output = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        token = list[_i];
        content = (function() {
          var _ref, _ref1;

          try {
            return (_ref = typeof token.render === "function" ? token.render(context) : void 0) != null ? _ref : token;
          } catch (_error) {
            e = _error;
            return (_ref1 = typeof context.handleError === "function" ? context.handleError(e) : void 0) != null ? _ref1 : String(e);
          }
        })();
        output.push(content);
      }
      return output;
    };

    Block.prototype.assertMissingDelimitation = function() {
      throw new Error("" + blockName + " tag was never closed");
    };

    return Block;

  })(Liquid.Tag);

  Liquid.Document = (function(_super) {
    __extends(Document, _super);

    function Document(tokens) {
      this.blockDelimiter = [];
      this.parse(tokens);
    }

    Document.prototype.assertMissingDelimitation = function() {};

    return Document;

  })(Liquid.Block);

  Liquid.Drop = (function() {
    function Drop() {}

    Drop.prototype.hasKey = function(name) {
      return true;
    };

    Drop.prototype.setContext = function(context) {
      this.context = context;
    };

    Drop.prototype.beforeMethod = function(method) {
      return null;
    };

    Drop.prototype.invokeDrop = function(method) {
      var results;

      results = this.beforeMethod(method);
      if (results == null) {
        if (objectHasKey(this, method)) {
          results = this[method].apply(this);
        }
      }
      return results;
    };

    return Drop;

  })();

  Liquid.Context = (function() {
    var FLOAT, INT, PART_PARSER, QUOTE, RANGE, SQUARE_PARSER, TICK;

    TICK = /^'(.*)'$/;

    QUOTE = /^"(.*)"$/;

    INT = /^(\d+)$/;

    FLOAT = /^(\d[\d\.]+)$/;

    RANGE = /^\((\S+)\.\.(\S+)\)$/;

    PART_PARSER = /\[[^\]]+\]|(?:[\w\-]\??)+/g;

    SQUARE_PARSER = /^\[(.*)\]$/;

    function Context(assigns, registers, rethrowErrors) {
      if (assigns == null) {
        assigns = {};
      }
      this.scopes = [assigns];
      this.registers = registers != null ? registers : {};
      this.errors = [];
      this.rethrowErrors = rethrowErrors;
      this.strainer = new Liquid.Strainer(this);
    }

    Context.prototype.get = function(key) {
      return this.resolve(key);
    };

    Context.prototype.set = function(key, value) {
      return this.scopes[0][key] = value;
    };

    Context.prototype.hasKey = function(key) {
      return this.resolve(key) != null;
    };

    Context.prototype.push = function() {
      var scope;

      scope = {};
      this.scopes.unshift(scope);
      return scope;
    };

    Context.prototype.merge = function(new_scope) {
      return objectExtend(this.scopes[0], new_scope);
    };

    Context.prototype.pop = function() {
      if (this.scopes.length === 1) {
        throw new Error("Context stack error");
      }
      return this.scopes.shift();
    };

    Context.prototype.stack = function(block, ctx) {
      var results;

      this.push();
      if (ctx == null) {
        ctx = this.strainer;
      }
      try {
        results = block.call(ctx);
      } finally {
        this.pop();
      }
      return results;
    };

    Context.prototype.invoke = function(method, args) {
      if (this.strainer.respondTo(method)) {
        return this.strainer.execute(method, args);
      } else {
        if (args.length === 0) {
          return null;
        } else {
          return args[0];
        }
      }
    };

    Context.prototype.resolve = function(key) {
      switch (key) {
        case null:
        case 'nil':
        case 'null':
        case '':
          return null;
        case 'true':
          return true;
        case 'false':
          return false;
        case 'blank':
        case 'empty':
          return '';
        default:
          return this.parseVariableType(key);
      }
    };

    Context.prototype.parseVariableType = function(key) {
      if (TICK.test(key)) {
        return key.replace(TICK, '$1');
      } else if (QUOTE.test(key)) {
        return key.replace(QUOTE, '$1');
      } else if (INT.test(key)) {
        return parseInt(key.replace(INT, '$1'), 10);
      } else if (FLOAT.test(key)) {
        return parseFloat(key.replace(FLOAT, '$1'));
      } else if (RANGE.test(key)) {
        return this.createRange(key);
      } else {
        return this.variable(key);
      }
    };

    Context.prototype.createRange = function(key) {
      var arr, i, l, left, limit, r, range, right, _i, _j, _ref;

      _ref = key.match(RANGE), range = _ref[0], l = _ref[1], r = _ref[2];
      left = parseInt(l, 10);
      right = parseInt(r, 10);
      arr = [];
      if (isNaN(left) || isNaN(right)) {
        left = l.charCodeAt(0);
        right = r.charCodeAt(0);
        limit = right - left + 1;
        for (i = _i = 0; 0 <= limit ? _i < limit : _i > limit; i = 0 <= limit ? ++_i : --_i) {
          arr.push(String.fromCharCode(i + left));
        }
      } else {
        limit = right - left + 1;
        for (i = _j = 0; 0 <= limit ? _j < limit : _j > limit; i = 0 <= limit ? ++_j : --_j) {
          arr.push(i + left);
        }
      }
      return arr;
    };

    Context.prototype.findVariable = function(key) {
      var scope, variable, _i, _len, _ref;

      _ref = this.scopes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        scope = _ref[_i];
        if ((scope != null) && type(scope[key]) !== 'undefined') {
          variable = scope[key];
          if (type(variable) === 'function') {
            variable = variable.apply(this);
            scope[key] = variable;
          }
          if (type(variable) === 'object') {
            if (objectHasKey(variable, 'toLiquid')) {
              variable = variable.toLiquid();
            }
            if (objectHasKey(variable, 'setContext')) {
              variable.setContext(this);
            }
          }
          return variable;
        }
      }
      return null;
    };

    Context.prototype.variable = function(markup) {
      var first_part, match, object, part, parts, pos, res, square_match, _i, _len;

      if (type(markup) !== 'string') {
        return null;
      }
      parts = markup.match(PART_PARSER);
      first_part = parts.shift();
      square_match = first_part.match(SQUARE_PARSER);
      if (square_match != null) {
        first_part = this.resolve(square_match[1]);
      }
      object = this.findVariable(first_part);
      if (object != null) {
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          part = parts[_i];
          match = part.match(SQUARE_PARSER);
          if (match != null) {
            part = this.resolve(match[1]);
            object = type(object[part]) === 'function' ? object[part].apply(this) : object[part];
            if (type(object) === 'object' && objectHasKey(object, 'toLiquid')) {
              object = object.toLiquid();
            }
          } else {
            if (type(object) === 'object' && objectHasKey(object, part)) {
              res = object[part];
              if (type(res) === 'function') {
                res = object[part] = res.apply(self);
              }
              object = type(res[part]) === 'object' && objectHasKey(res[part], 'toLiquid') ? res[part].toLiquid() : res;
            } else if (/^\d+$/.test(part)) {
              pos = parseInt(part, 10);
              if (type(object[pos]) === 'function') {
                object[pos] = object[pos].apply(this);
              }
              object = type(object[pos]) === 'object' && type(object[pos]) === 'object' && objectHasKey(object[pos], 'toLiquid') ? object[pos].toLiquid() : object[pos];
            } else if ((object != null) && type(object[part]) === 'function' && arrayHasItem(['length', 'size', 'first', 'last'], part)) {
              object = object[part].apply(part);
              if (objectHasKey(object, 'toLiquid')) {
                object = object.toLiquid();
              }
            } else {
              return object = null;
            }
            if (type(object) === 'object' && objectHasKey(object, 'setContext')) {
              object.setContext(this);
            }
          }
        }
      }
      return object;
    };

    Context.prototype.addFilters = function(filters) {
      var filter, _i, _len, _results;

      filters = arrayFlatten(filters);
      _results = [];
      for (_i = 0, _len = filters.length; _i < _len; _i++) {
        filter = filters[_i];
        if (type(filter) !== 'object') {
          throw new Error("Expected object but got: " + (type(filter)));
        }
        _results.push(objectExtend(this.strainer, filter));
      }
      return _results;
    };

    Context.prototype.handleError = function(err) {
      var _ref, _ref1;

      this.errors.push(err);
      if (this.rethrowErrors) {
        throw err;
      }
      return "Liquid error: " + ((_ref = (_ref1 = err.message) != null ? _ref1 : err.description) != null ? _ref : err);
    };

    return Context;

  })();

  Liquid.Strainer = (function() {
    function Strainer(context) {
      this.context = context;
    }

    Strainer.prototype.respondTo = function(method) {
      if (type(method) !== 'string') {
        return false;
      }
      if (method[0] === '_') {
        return false;
      }
      if (arrayHasItem(this.constructor.requiredMethods, method)) {
        return false;
      }
      return objectHasKey(this, method);
    };

    Strainer.prototype.execute = function(method, args) {
      return this[method].apply(this, args);
    };

    Strainer.requiredMethods = ['respondTo', 'context'];

    Strainer.registerFilter = function(filters) {
      var filter, fn;

      for (filter in filters) {
        fn = filters[filter];
        this.prototype[filter] = fn;
      }
      return this;
    };

    Strainer.registerFilters = Strainer.registerFilter;

    Strainer.globalFilter = Strainer.registerFilter;

    Strainer.create = function(context) {
      return new this(context);
    };

    return Strainer;

  })();

  Liquid.Variable = (function() {
    var FILTERS, FILTER_CLEANUP, FILTER_PARTS, VARIABLE, WORDS;

    VARIABLE = /\s*("[^"]+"|'[^']+'|[^\s,|]+)/;

    FILTERS = /\|\s*(.*)/;

    WORDS = /\s*(\w+)/;

    FILTER_PARTS = /(?:[:|,]\s*)("[^"]+"|'[^']+'|[^\s,|]+)/g;

    FILTER_CLEANUP = /^[\s|:|,]*(.*?)[\s]*$/;

    function Variable(markup) {
      var arg, args, cleaned, filter, filter_matches, filters, match, matches, name, parts, _i, _j, _len, _len1, _ref;

      this.markup = markup;
      this.name = null;
      this.filters = [];
      match = this.markup.match(VARIABLE);
      if (match != null) {
        this.name = match[1];
        filter_matches = markup.match(FILTERS);
        if (filter_matches != null) {
          filters = filter_matches[1].split('|');
          for (_i = 0, _len = filters.length; _i < _len; _i++) {
            filter = filters[_i];
            matches = filter.match(WORDS);
            if (matches != null) {
              name = matches[1];
              args = [];
              parts = (_ref = filter.match(FILTER_PARTS)) != null ? _ref : [];
              for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
                arg = parts[_j];
                cleaned = arg.match(FILTER_CLEANUP);
                if (cleaned != null) {
                  args.push(cleaned[1]);
                }
              }
              this.filters.push([name, args]);
            }
          }
        }
      }
    }

    Variable.prototype.render = function(context) {
      var args, name, output, _i, _len, _ref, _ref1;

      if (this.name == null) {
        return '';
      }
      output = context.get(this.name);
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], name = _ref1[0], args = _ref1[1];
        args = arrayMap(args, function(arg) {
          return context.get(arg);
        });
        args.unshift(output);
        output = context.invoke(name, args);
      }
      return output;
    };

    return Variable;

  })();

  Liquid.Condition = (function() {
    function Condition(left, operator, right) {
      this.left = left;
      this.operator = operator;
      this.right = right;
      this.childRelation = null;
      this.childCondition = null;
      this.attachment = null;
    }

    Condition.prototype.evaluate = function(context) {
      var result;

      if (context == null) {
        context = new Liquid.Context();
      }
      result = this.interpretCondition(this.left, this.right, this.operator, context);
      switch (this.childRelation) {
        case 'or':
          return result || this.childCondition.evaluate(context);
        case 'and':
          return result && this.childCondition.evaluate(context);
        default:
          return result;
      }
    };

    Condition.prototype.or = function(condition) {
      this.childRelation = 'or';
      return this.childCondition = condition;
    };

    Condition.prototype.and = function(condition) {
      this.childRelation = 'and';
      return this.childCondition = condition;
    };

    Condition.prototype.attach = function(attachment) {
      return this.attachment = attachment;
    };

    Condition.prototype.isElse = false;

    Condition.prototype.interpretCondition = function(left, right, op, ctx) {
      if (op == null) {
        return ctx.get(left);
      }
      left = ctx.get(left);
      right = ctx.get(right);
      op = this.constructor.operators[op];
      if (op == null) {
        throw new Error("Unknown operator " + op);
      }
      return op(left, right);
    };

    Condition.prototype.toString = function() {
      return "<Condition " + this.left + " " + this.operator + " " + this.right + ">";
    };

    Condition.operators = {
      '==': function(l, r) {
        return l === r;
      },
      '=': function(l, r) {
        return l === r;
      },
      '!=': function(l, r) {
        return l !== r;
      },
      '<>': function(l, r) {
        return l !== r;
      },
      '<': function(l, r) {
        return l < r;
      },
      '>': function(l, r) {
        return l > r;
      },
      '<=': function(l, r) {
        return l <= r;
      },
      '>=': function(l, r) {
        return l >= r;
      },
      contains: function(l, r) {
        return arrayHasItem(l, r);
      },
      hasKey: function(l, r) {
        return objectHasKey(l, r);
      },
      hasValue: function(l, r) {
        return objectHasValue(l, r);
      }
    };

    return Condition;

  })();

  Liquid.ElseCondition = (function(_super) {
    __extends(ElseCondition, _super);

    function ElseCondition() {
      _ref = ElseCondition.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    ElseCondition.prototype.isElse = true;

    ElseCondition.prototype.evaluate = function() {
      return true;
    };

    ElseCondition.prototype.toString = function() {
      return "<ElseCondition>";
    };

    return ElseCondition;

  })(Liquid.Condition);

  Liquid.Template = (function() {
    var TOKENIZER;

    TOKENIZER = /(\{\%.*?\%\}|\{\{.*?\}\}?)/;

    function Template() {
      this.root = null;
      this.registers = {};
      this.assigns = {};
      this.errors = [];
      this.rethrowErrors = false;
    }

    Template.prototype.parse = function(src) {
      this.root = new Liquid.Document(this.constructor.tokenize(src));
      return this;
    };

    Template.prototype.render = function() {
      var args, context, results;

      if (this.root == null) {
        return '';
      }
      args = {
        ctx: arguments[0],
        filters: arguments[1],
        registers: arguments[2]
      };
      context = null;
      if (args.ctx instanceof Liquid.Context) {
        context = args.ctx;
        this.assigns = context.assigns;
        this.registers = context.registers;
      } else {
        if (args.ctx != null) {
          objectExtend(this.assigns, args.ctx);
        }
        if (args.registers != null) {
          objectExtend(this.registers, args.registers);
        }
        context = new Liquid.Context(this.assigns, this.registers, this.rethrowErrors);
      }
      if (args.filters != null) {
        context.addFilters(args.filters);
      }
      try {
        results = this.root.render(context).join('');
      } finally {
        this.errors = context.errors;
      }
      return results;
    };

    Template.prototype.renderWithErrors = function() {
      var oldErrorVal, results;

      oldErrorVal = this.rethrowErrors;
      this.rethrowErrors = true;
      results = this.render.apply(this, arguments);
      this.rethrowErrors = oldErrorVal;
      return results;
    };

    Template.tags = {};

    Template.registerTag = function(name, cls) {
      this.tags[name] = cls;
      return this;
    };

    Template.registerFilter = function(filters) {
      Liquid.Strainer.registerFilters(filters);
      return this;
    };

    Template.registerFilters = Template.registerFilter;

    Template.tokenize = function(src) {
      var tokens;

      tokens = src.split(TOKENIZER);
      if (tokens[0] === '') {
        tokens.shift();
      }
      return tokens;
    };

    Template.parse = function(src) {
      return new this().parse(src);
    };

    return Template;

  })();

  Liquid.Template.registerFilter({
    date: function(input, format) {
      var date;

      date = input instanceof Date ? input : input === 'now' ? new Date() : new Date(input);
      if (!(date instanceof Date)) {
        date = new Date(Date.parse(input));
      }
      if (date instanceof Date) {
        return date.strftime(format);
      } else {
        return input;
      }
    }
  });

  Liquid.Template.registerFilter({
    size: function(arr) {
      var _ref1;

      return (_ref1 = arr.length) != null ? _ref1 : 0;
    },
    join: function(arr, sep) {
      if (sep == null) {
        sep = ' ';
      }
      return arr.join(sep);
    },
    first: function(arr) {
      return arrayFirst(arr);
    },
    last: function(arr) {
      return arrayLast(arr);
    },
    sort: function(arr) {
      return arr.sort();
    },
    reverse: function(arr) {
      return arr.reverse();
    }
  });

  escape_str = function(input) {
    return input.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  };

  truncate_words = function(input, words, string) {
    var l, wordlist;

    if (words == null) {
      words = '15';
    }
    if (string == null) {
      string = '...';
    }
    if (!((input != null) && input !== '')) {
      return '';
    }
    words = parseInt(words, 10);
    wordlist = input.toString().split(" ");
    l = Math.max(words, 0);
    if (wordlist.length > l) {
      return wordlist.slice(0, l).join(' ') + string;
    } else {
      return input;
    }
  };

  Liquid.Template.registerFilter({
    downcase: function(input) {
      return input.toString().toLowerCase();
    },
    upcase: function(input) {
      return input.toString().toUpperCase();
    },
    capitalize: function(input) {
      return stringCapitalize(input);
    },
    replace: function(input, string, replacement) {
      if (replacement == null) {
        replacement = '';
      }
      return input.toString().replace(new RegExp(string, 'g'), replacement);
    },
    replace_first: function(input, string, replacement) {
      if (replacement == null) {
        replacement = '';
      }
      return input.toString().replace(new RegExp(string, ""), replacement);
    },
    escape: escape_str,
    h: escape_str,
    truncate: function(input, length, string) {
      var seg;

      if (length == null) {
        length = 50;
      }
      if (string == null) {
        string = "...";
      }
      if (!((input != null) && input !== '')) {
        return '';
      }
      seg = input.slice(0, length);
      if (input.length > length) {
        return input.slice(0, length) + string;
      } else {
        return input;
      }
    },
    truncatewords: truncate_words,
    truncate_words: truncate_words,
    strip_html: function(input) {
      return input.toString().replace(/<.*?>/g, '');
    },
    strip_newlines: function(input) {
      return input.toString().replace(/\n/g, '');
    },
    newline_to_br: function(input) {
      return input.toString().replace(/\n/g, "<br/>\n");
    }
  });

  AssignTag = (function(_super) {
    var tagSyntax;

    __extends(AssignTag, _super);

    tagSyntax = /((?:\(?[\w\-\.\[\]]\)?)+)\s*=\s*((?:"[^"]+"|'[^']+'|[^\s,|]+)+)/;

    function AssignTag(tag, markup, tokens) {
      var parts, _;

      parts = markup.match(tagSyntax);
      if (parts == null) {
        throw new Error("Syntax error in 'assign' - Valid syntax: assign [var] = [source]");
      }
      _ = parts[0], this.to = parts[1], this.from = parts[2];
      AssignTag.__super__.constructor.call(this, tag, markup, tokens);
    }

    AssignTag.prototype.render = function(ctx) {
      arrayLast(ctx.scopes)[this.to] = ctx.get(this.from);
      return "";
    };

    return AssignTag;

  })(Liquid.Tag);

  Liquid.Template.registerTag('assign', AssignTag);

  CaptureTag = (function(_super) {
    var tagSyntax;

    __extends(CaptureTag, _super);

    tagSyntax = /(\w+)/;

    function CaptureTag(tagName, markup, tokens) {
      var parts;

      parts = markup.match(tagSyntax);
      if (parts == null) {
        throw "Syntax error in '" + tagName + "' - Valid syntax: capture [var]";
      }
      this.to = parts[1];
      CaptureTag.__super__.constructor.call(this, tagName, markup, tokens);
    }

    CaptureTag.prototype.render = function(context) {
      var output;

      output = CaptureTag.__super__.render.call(this, context);
      context.set(this.to, arrayFlatten([output]).join(''));
      return '';
    };

    return CaptureTag;

  })(Liquid.Block);

  CacheTag = (function(_super) {
    __extends(CacheTag, _super);

    function CacheTag() {
      _ref1 = CacheTag.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    CacheTag.prototype.render = function(context) {
      var output;

      output = CacheTag.__super__.render.call(this, context);
      arrayLast(context.scopes)[this.to] = arrayFlatten([output]).join('');
      return '';
    };

    return CacheTag;

  })(CaptureTag);

  Liquid.Template.registerTag('cache', CacheTag);

  Liquid.Template.registerTag('capture', CaptureTag);

  CommentTag = (function(_super) {
    __extends(CommentTag, _super);

    function CommentTag() {
      _ref2 = CommentTag.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    CommentTag.prototype.render = function() {
      return '';
    };

    return CommentTag;

  })(Liquid.Block);

  Liquid.Template.registerTag('comment', CommentTag);

}).call(this);
/* Cross-Browser Split 1.0.1
(c) Steven Levithan <stevenlevithan.com>; MIT License
An ECMA-compliant, uniform cross-browser split method 

Fixes problems with IE's broken String#split method.
See http://blog.stevenlevithan.com/archives/cross-browser-split
*/

var cbSplit;

// avoid running twice, which would break `cbSplit._nativeSplit`'s reference to the native `split`
if (!cbSplit) {

cbSplit = function (str, separator, limit) {
    // if `separator` is not a regex, use the native `split`
    if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
        return cbSplit._nativeSplit.call(str, separator, limit);
    }

    var output = [],
        lastLastIndex = 0,
        flags = (separator.ignoreCase ? "i" : "") +
                (separator.multiline  ? "m" : "") +
                (separator.sticky     ? "y" : ""),
        separator = RegExp(separator.source, flags + "g"), // make `global` and avoid `lastIndex` issues by working with a copy
        separator2, match, lastIndex, lastLength;

    str = str + ""; // type conversion
    if (!cbSplit._compliantExecNpcg) {
        separator2 = RegExp("^" + separator.source + "$(?!\\s)", flags); // doesn't need /g or /y, but they don't hurt
    }

    /* behavior for `limit`: if it's...
    - `undefined`: no limit.
    - `NaN` or zero: return an empty array.
    - a positive number: use `Math.floor(limit)`.
    - a negative number: no limit.
    - other: type-convert, then use the above rules. */
    if (limit === undefined || +limit < 0) {
        limit = Infinity;
    } else {
        limit = Math.floor(+limit);
        if (!limit) {
            return [];
        }
    }

    while (match = separator.exec(str)) {
        lastIndex = match.index + match[0].length; // `separator.lastIndex` is not reliable cross-browser

        if (lastIndex > lastLastIndex) {
            output.push(str.slice(lastLastIndex, match.index));

            // fix browsers whose `exec` methods don't consistently return `undefined` for nonparticipating capturing groups
            if (!cbSplit._compliantExecNpcg && match.length > 1) {
                match[0].replace(separator2, function () {
                    for (var i = 1; i < arguments.length - 2; i++) {
                        if (arguments[i] === undefined) {
                            match[i] = undefined;
                        }
                    }
                });
            }

            if (match.length > 1 && match.index < str.length) {
                Array.prototype.push.apply(output, match.slice(1));
            }

            lastLength = match[0].length;
            lastLastIndex = lastIndex;

            if (output.length >= limit) {
                break;
            }
        }

        if (separator.lastIndex === match.index) {
            separator.lastIndex++; // avoid an infinite loop
        }
    }

    if (lastLastIndex === str.length) {
        if (lastLength || !separator.test("")) {
            output.push("");
        }
    } else {
        output.push(str.slice(lastLastIndex));
    }

    return output.length > limit ? output.slice(0, limit) : output;
};

cbSplit._compliantExecNpcg = /()??/.exec("")[1] === undefined; // NPCG: nonparticipating capturing group
cbSplit._nativeSplit = String.prototype.split;

} // end `if (!cbSplit)`

// for convenience...
String.prototype.split = function (separator, limit) {
    return cbSplit(this, separator, limit);
};
// Includes inline strftime support...
if(!(new Date()).strftime) {(function(){
Date.ext={};Date.ext.util={};Date.ext.util.xPad=function(x,pad,r){if(typeof (r)=="undefined"){r=10}for(;parseInt(x,10)<r&&r>1;r/=10){x=pad.toString()+x}return x.toString()};Date.prototype.locale="en-GB";if(document.getElementsByTagName("html")&&document.getElementsByTagName("html")[0].lang){Date.prototype.locale=document.getElementsByTagName("html")[0].lang}Date.ext.locales={};Date.ext.locales.en={a:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],A:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],b:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],B:["January","February","March","April","May","June","July","August","September","October","November","December"],c:"%a %d %b %Y %T %Z",p:["AM","PM"],P:["am","pm"],x:"%d/%m/%y",X:"%T"};Date.ext.locales["en-US"]=Date.ext.locales.en;Date.ext.locales["en-US"].c="%a %d %b %Y %r %Z";Date.ext.locales["en-US"].x="%D";Date.ext.locales["en-US"].X="%r";Date.ext.locales["en-GB"]=Date.ext.locales.en;Date.ext.locales["en-AU"]=Date.ext.locales["en-GB"];Date.ext.formats={a:function(d){return Date.ext.locales[d.locale].a[d.getDay()]},A:function(d){return Date.ext.locales[d.locale].A[d.getDay()]},b:function(d){return Date.ext.locales[d.locale].b[d.getMonth()]},B:function(d){return Date.ext.locales[d.locale].B[d.getMonth()]},c:"toLocaleString",C:function(d){return Date.ext.util.xPad(parseInt(d.getFullYear()/100,10),0)},d:["getDate","0"],e:["getDate"," "],g:function(d){return Date.ext.util.xPad(parseInt(Date.ext.util.G(d)/100,10),0)},G:function(d){var y=d.getFullYear();var V=parseInt(Date.ext.formats.V(d),10);var W=parseInt(Date.ext.formats.W(d),10);if(W>V){y++}else{if(W===0&&V>=52){y--}}return y},H:["getHours","0"],I:function(d){var I=d.getHours()%12;return Date.ext.util.xPad(I===0?12:I,0)},j:function(d){var ms=d-new Date(""+d.getFullYear()+"/1/1 GMT");ms+=d.getTimezoneOffset()*60000;var doy=parseInt(ms/60000/60/24,10)+1;return Date.ext.util.xPad(doy,0,100)},m:function(d){return Date.ext.util.xPad(d.getMonth()+1,0)},M:["getMinutes","0"],p:function(d){return Date.ext.locales[d.locale].p[d.getHours()>=12?1:0]},P:function(d){return Date.ext.locales[d.locale].P[d.getHours()>=12?1:0]},S:["getSeconds","0"],u:function(d){var dow=d.getDay();return dow===0?7:dow},U:function(d){var doy=parseInt(Date.ext.formats.j(d),10);var rdow=6-d.getDay();var woy=parseInt((doy+rdow)/7,10);return Date.ext.util.xPad(woy,0)},V:function(d){var woy=parseInt(Date.ext.formats.W(d),10);var dow1_1=(new Date(""+d.getFullYear()+"/1/1")).getDay();var idow=woy+(dow1_1>4||dow1_1<=1?0:1);if(idow==53&&(new Date(""+d.getFullYear()+"/12/31")).getDay()<4){idow=1}else{if(idow===0){idow=Date.ext.formats.V(new Date(""+(d.getFullYear()-1)+"/12/31"))}}return Date.ext.util.xPad(idow,0)},w:"getDay",W:function(d){var doy=parseInt(Date.ext.formats.j(d),10);var rdow=7-Date.ext.formats.u(d);var woy=parseInt((doy+rdow)/7,10);return Date.ext.util.xPad(woy,0,10)},y:function(d){return Date.ext.util.xPad(d.getFullYear()%100,0)},Y:"getFullYear",z:function(d){var o=d.getTimezoneOffset();var H=Date.ext.util.xPad(parseInt(Math.abs(o/60),10),0);var M=Date.ext.util.xPad(o%60,0);return(o>0?"-":"+")+H+M},Z:function(d){return d.toString().replace(/^.*\(([^)]+)\)$/,"$1")},"%":function(d){return"%"}};Date.ext.aggregates={c:"locale",D:"%m/%d/%y",h:"%b",n:"\n",r:"%I:%M:%S %p",R:"%H:%M",t:"\t",T:"%H:%M:%S",x:"locale",X:"locale"};Date.ext.aggregates.z=Date.ext.formats.z(new Date());Date.ext.aggregates.Z=Date.ext.formats.Z(new Date());Date.ext.unsupported={};Date.prototype.strftime=function(fmt){if(!(this.locale in Date.ext.locales)){if(this.locale.replace(/-[a-zA-Z]+$/,"") in Date.ext.locales){this.locale=this.locale.replace(/-[a-zA-Z]+$/,"")}else{this.locale="en-GB"}}var d=this;while(fmt.match(/%[cDhnrRtTxXzZ]/)){fmt=fmt.replace(/%([cDhnrRtTxXzZ])/g,function(m0,m1){var f=Date.ext.aggregates[m1];return(f=="locale"?Date.ext.locales[d.locale][m1]:f)})}var str=fmt.replace(/%([aAbBCdegGHIjmMpPSuUVwWyY%])/g,function(m0,m1){var f=Date.ext.formats[m1];if(typeof (f)=="string"){return d[f]()}else{if(typeof (f)=="function"){return f.call(d,d)}else{if(typeof (f)=="object"&&typeof (f[0])=="string"){return Date.ext.util.xPad(d[f[0]](),f[1])}else{return m1}}}});d=null;return str};
})();}
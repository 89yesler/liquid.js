// Generated by CoffeeScript 1.6.2
(function() {
  var AssignTag, CacheTag, CaptureTag, CommentTag, Liquid, arrayClear, arrayFirst, arrayFlatten, arrayHasItem, arrayIndexOf, arrayLast, arrayMap, escape_str, objectDefaults, objectExtend, objectHasKey, objectHasValue, stringCapitalize, stringTrim, truncate_words, type, _ref, _ref1, _ref2,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  Liquid = {
    author: "Matt McCray",
    version: "2.0.1",
    readTemplateFile: function(path) {
      throw new Error("This liquid context does not allow includes.");
    },
    registerFilters: function(filters) {
      return Liquid.Template.registerFilters(filters);
    },
    parse: function(src) {
      return Liquid.Template.parse(src);
    }
  };

  if (typeof window !== "undefined" && window !== null) {
    window.Liquid = Liquid;
  } else if (typeof module !== "undefined" && module !== null) {
    module.exports = Liquid;
  }

  type = (function() {
    var classToType, elemParser, name, toStr, _i, _len, _ref;

    toStr = Object.prototype.toString;
    elemParser = /\[object HTML(.*)\]/;
    classToType = {};
    _ref = "Boolean Number String Function Array Date RegExp Undefined Null NodeList".split(" ");
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      name = _ref[_i];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    return function(obj) {
      var found, strType;

      strType = toStr.call(obj);
      if (found = classToType[strType]) {
        return found;
      } else if (found = strType.match(elemParser)) {
        return found[1].toLowerCase();
      } else {
        return "object";
      }
    };
  })();

  objectHasKey = function(object, key) {
    return (key in object);
  };

  objectHasValue = function(object, targetValue) {
    var key, value;

    for (key in object) {
      value = object[key];
      if (value === targetValue) {
        return true;
      }
    }
    return false;
  };

  objectExtend = function(object) {
    var key, source, value, _i, _len, _ref;

    _ref = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      source = _ref[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          object[key] = value;
        }
      }
    }
    return object;
  };

  objectDefaults = function(object) {
    var key, source, value, _i, _len, _ref;

    _ref = Array.prototype.slice.call(arguments, 1);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      source = _ref[_i];
      if (source) {
        for (key in source) {
          value = source[key];
          if (object[key] == null) {
            object[key] = value;
          } else if (type(object[key]) === 'object') {
            object[key] = objectDefaults({}, object[key], value);
          }
        }
      }
    }
    return object;
  };

  arrayMap = (function() {
    if (Array.prototype.map != null) {
      return function(array, fn, ctx) {
        return array.map(fn, ctx);
      };
    } else {
      return function(array, fn, ctx) {
        var i, item, results, _i, _len;

        results = [];
        for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
          item = array[i];
          results.push(fn.call(ctx, item, i, ctx));
        }
        return results;
      };
    }
  })();

  arrayFlatten = function(array) {
    var item, new_array, sub_array, _i, _len;

    new_array = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (type(item) === 'array') {
        sub_array = arrayFlatten(item);
        new_array = new_array.concat(sub_array);
      } else {
        new_array.push(item);
      }
    }
    return new_array;
  };

  arrayIndexOf = function(array, targetItem) {
    var i, item, _i, _len;

    if (array.indexOf != null) {
      return array.indexOf(targetItem);
    } else {
      for (i = _i = 0, _len = array.length; _i < _len; i = ++_i) {
        item = array[i];
        if (item === targetItem) {
          return i;
        }
      }
      return -1;
    }
  };

  arrayHasItem = function(array, targetItem) {
    return arrayIndexOf(array, targetItem) > -1;
  };

  arrayClear = function(array) {
    return array.length = 0;
  };

  arrayFirst = function(array) {
    return array[0];
  };

  arrayLast = function(array) {
    return array[array.length - 1];
  };

  stringTrim = (function() {
    if (String.prototype.trim != null) {
      return function(str) {
        return str.trim();
      };
    } else {
      return function(str) {
        return str.replace(stringTrim.RE_START, '').replace(stringTrim.RE_END, '');
      };
    }
  })();

  stringTrim.RE_START = /^\s+/;

  stringTrim.RE_END = /^\s+$/;

  stringCapitalize = function(str) {
    return str.charAt(0).toUpperCase() + str.substring(1).toLowerCase();
  };

  Liquid.Tag = (function() {
    function Tag(tagName, markup, tokens) {
      var _ref;

      this.tagName = tagName;
      this.markup = markup;
      if ((_ref = this.nodelist) == null) {
        this.nodelist = [];
      }
      this.parse(tokens);
    }

    Tag.prototype.parse = function(tokens) {};

    Tag.prototype.render = function(context) {
      return "";
    };

    return Tag;

  })();

  Liquid.Block = (function(_super) {
    var TAG_OPEN, TAG_PARTS, VAR_OPEN, VAR_PARTS;

    __extends(Block, _super);

    TAG_OPEN = /^\{\%/;

    TAG_PARTS = /^\{\%\s*(\w+)\s*(.*)?\%\}$/;

    VAR_OPEN = /^\{\{/;

    VAR_PARTS = /^\{\{(.*)\}\}$/;

    function Block(tagName, markup, tokens) {
      this.blockName = tagName;
      this.blockDelimiter = "end" + this.blockName;
      Block.__super__.constructor.call(this, tagName, markup, tokens);
    }

    Block.prototype.parse = function(tokens) {
      var content, tag, tag_parts, token, _, _ref;

      if ((_ref = this.nodelist) == null) {
        this.nodelist = [];
      }
      token = tokens.shift();
      tokens.push('');
      while (tokens.length) {
        if (TAG_OPEN.test(token)) {
          tag_parts = token.match(TAG_PARTS);
          if (tag_parts == null) {
            throw new Error("Tag '" + token + "' was not properly terminated with '%}'");
          }
          _ = tag_parts[0], tag = tag_parts[1], content = tag_parts[2];
          if (tag === this.blockDelimiter) {
            return this.endTag();
          }
          if (objectHasKey(Liquid.Template.tags, tag)) {
            this.nodelist.push(new Liquid.Template.tags[tag](tag, content, tokens));
          } else {
            this.unknownTag(tag, content, tokens);
          }
        } else if (VAR_OPEN.test(token)) {
          this.nodelist.push(this.createVariable(token));
        } else {
          this.nodelist.push(token);
        }
        token = tokens.shift();
      }
    };

    Block.prototype.endTag = function() {};

    Block.prototype.unknownTag = function(tag, params, tokens) {
      var msg;

      msg = (function() {
        switch (tag) {
          case 'else':
            return "" + this.blockName + " tag does not expect else tag";
          case 'end':
            return "'end' is not a valid delimiter for " + this.blockName + " tags. use " + this.blockDelimiter;
          default:
            return "Unknown tag: " + tag;
        }
      }).call(this);
      throw new Error(msg);
    };

    Block.prototype.createVariable = function(token) {
      var match;

      match = token.match(VAR_PARTS);
      if (match != null) {
        return new Liquid.Variable(match[1]);
      } else {
        throw new Error("Variable '" + token + "' was not properly terminated with: }}");
      }
    };

    Block.prototype.render = function(context) {
      return this.renderAll(this.nodelist, context);
    };

    Block.prototype.renderAll = function(list, context) {
      var content, e, output, token, _i, _len;

      if (list == null) {
        list = [];
      }
      if (context == null) {
        context = {};
      }
      output = [];
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        token = list[_i];
        content = (function() {
          var _ref, _ref1;

          try {
            return (_ref = typeof token.render === "function" ? token.render(context) : void 0) != null ? _ref : token;
          } catch (_error) {
            e = _error;
            return (_ref1 = typeof context.handleError === "function" ? context.handleError(e) : void 0) != null ? _ref1 : String(e);
          }
        })();
        output.push(content);
      }
      return output;
    };

    Block.prototype.assertMissingDelimitation = function() {
      throw new Error("" + blockName + " tag was never closed");
    };

    return Block;

  })(Liquid.Tag);

  Liquid.Document = (function(_super) {
    __extends(Document, _super);

    function Document(tokens) {
      this.blockDelimiter = [];
      this.parse(tokens);
    }

    Document.prototype.assertMissingDelimitation = function() {};

    return Document;

  })(Liquid.Block);

  Liquid.Drop = (function() {
    function Drop() {}

    Drop.prototype.hasKey = function(name) {
      return true;
    };

    Drop.prototype.setContext = function(context) {
      this.context = context;
    };

    Drop.prototype.beforeMethod = function(method) {
      return null;
    };

    Drop.prototype.invokeDrop = function(method) {
      var results;

      results = this.beforeMethod(method);
      if (results == null) {
        if (objectHasKey(this, method)) {
          results = this[method].apply(this);
        }
      }
      return results;
    };

    return Drop;

  })();

  Liquid.Context = (function() {
    var FLOAT, INT, PART_PARSER, QUOTE, RANGE, SQUARE_PARSER, TICK;

    TICK = /^'(.*)'$/;

    QUOTE = /^"(.*)"$/;

    INT = /^(\d+)$/;

    FLOAT = /^(\d[\d\.]+)$/;

    RANGE = /^\((\S+)\.\.(\S+)\)$/;

    PART_PARSER = /\[[^\]]+\]|(?:[\w\-]\??)+/g;

    SQUARE_PARSER = /^\[(.*)\]$/;

    function Context(assigns, registers, rethrowErrors) {
      if (assigns == null) {
        assigns = {};
      }
      this.scopes = [assigns];
      this.registers = registers != null ? registers : {};
      this.errors = [];
      this.rethrowErrors = rethrowErrors;
      this.strainer = new Liquid.Strainer(this);
    }

    Context.prototype.get = function(key) {
      return this.resolve(key);
    };

    Context.prototype.set = function(key, value) {
      return this.scopes[0][key] = value;
    };

    Context.prototype.hasKey = function(key) {
      return this.resolve(key) != null;
    };

    Context.prototype.push = function() {
      var scope;

      scope = {};
      this.scopes.unshift(scope);
      return scope;
    };

    Context.prototype.merge = function(new_scope) {
      return objectExtend(this.scopes[0], new_scope);
    };

    Context.prototype.pop = function() {
      if (this.scopes.length === 1) {
        throw new Error("Context stack error");
      }
      return this.scopes.shift();
    };

    Context.prototype.stack = function(block, ctx) {
      var results;

      this.push();
      if (ctx == null) {
        ctx = this.strainer;
      }
      try {
        results = block.call(ctx);
      } finally {
        this.pop();
      }
      return results;
    };

    Context.prototype.invoke = function(method, args) {
      if (this.strainer.respondTo(method)) {
        return this.strainer.execute(method, args);
      } else {
        if (args.length === 0) {
          return null;
        } else {
          return args[0];
        }
      }
    };

    Context.prototype.resolve = function(key) {
      switch (key) {
        case null:
        case 'nil':
        case 'null':
        case '':
          return null;
        case 'true':
          return true;
        case 'false':
          return false;
        case 'blank':
        case 'empty':
          return '';
        default:
          return this.parseVariableType(key);
      }
    };

    Context.prototype.parseVariableType = function(key) {
      if (TICK.test(key)) {
        return key.replace(TICK, '$1');
      } else if (QUOTE.test(key)) {
        return key.replace(QUOTE, '$1');
      } else if (INT.test(key)) {
        return parseInt(key.replace(INT, '$1'), 10);
      } else if (FLOAT.test(key)) {
        return parseFloat(key.replace(FLOAT, '$1'));
      } else if (RANGE.test(key)) {
        return this.createRange(key);
      } else {
        return this.variable(key);
      }
    };

    Context.prototype.createRange = function(key) {
      var arr, i, l, left, limit, r, range, right, _i, _j, _ref;

      _ref = key.match(RANGE), range = _ref[0], l = _ref[1], r = _ref[2];
      left = parseInt(l, 10);
      right = parseInt(r, 10);
      arr = [];
      if (isNaN(left) || isNaN(right)) {
        left = l.charCodeAt(0);
        right = r.charCodeAt(0);
        limit = right - left + 1;
        for (i = _i = 0; 0 <= limit ? _i < limit : _i > limit; i = 0 <= limit ? ++_i : --_i) {
          arr.push(String.fromCharCode(i + left));
        }
      } else {
        limit = right - left + 1;
        for (i = _j = 0; 0 <= limit ? _j < limit : _j > limit; i = 0 <= limit ? ++_j : --_j) {
          arr.push(i + left);
        }
      }
      return arr;
    };

    Context.prototype.findVariable = function(key) {
      var scope, variable, _i, _len, _ref;

      _ref = this.scopes;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        scope = _ref[_i];
        if ((scope != null) && type(scope[key]) !== 'undefined') {
          variable = scope[key];
          if (type(variable) === 'function') {
            variable = variable.apply(this);
            scope[key] = variable;
          }
          if (type(variable) === 'object') {
            if (objectHasKey(variable, 'toLiquid')) {
              variable = variable.toLiquid();
            }
            if (objectHasKey(variable, 'setContext')) {
              variable.setContext(this);
            }
          }
          return variable;
        }
      }
      return null;
    };

    Context.prototype.variable = function(markup) {
      var first_part, match, object, part, parts, pos, res, square_match, _i, _len;

      if (type(markup) !== 'string') {
        return null;
      }
      parts = markup.match(PART_PARSER);
      first_part = parts.shift();
      square_match = first_part.match(SQUARE_PARSER);
      if (square_match != null) {
        first_part = this.resolve(square_match[1]);
      }
      object = this.findVariable(first_part);
      if (object != null) {
        for (_i = 0, _len = parts.length; _i < _len; _i++) {
          part = parts[_i];
          match = part.match(SQUARE_PARSER);
          if (match != null) {
            part = this.resolve(match[1]);
            object = type(object[part]) === 'function' ? object[part].apply(this) : object[part];
            if (type(object) === 'object' && objectHasKey(object, 'toLiquid')) {
              object = object.toLiquid();
            }
          } else {
            if (type(object) === 'object' && objectHasKey(object, part)) {
              res = object[part];
              if (type(res) === 'function') {
                res = object[part] = res.apply(self);
              }
              object = type(res[part]) === 'object' && objectHasKey(res[part], 'toLiquid') ? res[part].toLiquid() : res;
            } else if (/^\d+$/.test(part)) {
              pos = parseInt(part, 10);
              if (type(object[pos]) === 'function') {
                object[pos] = object[pos].apply(this);
              }
              object = type(object[pos]) === 'object' && type(object[pos]) === 'object' && objectHasKey(object[pos], 'toLiquid') ? object[pos].toLiquid() : object[pos];
            } else if ((object != null) && type(object[part]) === 'function' && arrayHasItem(['length', 'size', 'first', 'last'], part)) {
              object = object[part].apply(part);
              if (objectHasKey(object, 'toLiquid')) {
                object = object.toLiquid();
              }
            } else {
              return object = null;
            }
            if (type(object) === 'object' && objectHasKey(object, 'setContext')) {
              object.setContext(this);
            }
          }
        }
      }
      return object;
    };

    Context.prototype.addFilters = function(filters) {
      var filter, _i, _len, _results;

      filters = arrayFlatten(filters);
      _results = [];
      for (_i = 0, _len = filters.length; _i < _len; _i++) {
        filter = filters[_i];
        if (type(filter) !== 'object') {
          throw new Error("Expected object but got: " + (type(filter)));
        }
        _results.push(objectExtend(this.strainer, filter));
      }
      return _results;
    };

    Context.prototype.handleError = function(err) {
      var _ref, _ref1;

      this.errors.push(err);
      if (this.rethrowErrors) {
        throw err;
      }
      return "Liquid error: " + ((_ref = (_ref1 = err.message) != null ? _ref1 : err.description) != null ? _ref : err);
    };

    return Context;

  })();

  Liquid.Strainer = (function() {
    function Strainer(context) {
      this.context = context;
    }

    Strainer.prototype.respondTo = function(method) {
      if (type(method) !== 'string') {
        return false;
      }
      if (method[0] === '_') {
        return false;
      }
      if (arrayHasItem(this.constructor.requiredMethods, method)) {
        return false;
      }
      return objectHasKey(this, method);
    };

    Strainer.prototype.execute = function(method, args) {
      return this[method].apply(this, args);
    };

    Strainer.requiredMethods = ['respondTo', 'context'];

    Strainer.registerFilter = function(filters) {
      var filter, fn;

      for (filter in filters) {
        fn = filters[filter];
        this.prototype[filter] = fn;
      }
      return this;
    };

    Strainer.registerFilters = Strainer.registerFilter;

    Strainer.globalFilter = Strainer.registerFilter;

    Strainer.create = function(context) {
      return new this(context);
    };

    return Strainer;

  })();

  Liquid.Variable = (function() {
    var FILTERS, FILTER_CLEANUP, FILTER_PARTS, VARIABLE, WORDS;

    VARIABLE = /\s*("[^"]+"|'[^']+'|[^\s,|]+)/;

    FILTERS = /\|\s*(.*)/;

    WORDS = /\s*(\w+)/;

    FILTER_PARTS = /(?:[:|,]\s*)("[^"]+"|'[^']+'|[^\s,|]+)/g;

    FILTER_CLEANUP = /^[\s|:|,]*(.*?)[\s]*$/;

    function Variable(markup) {
      var arg, args, cleaned, filter, filter_matches, filters, match, matches, name, parts, _i, _j, _len, _len1, _ref;

      this.markup = markup;
      this.name = null;
      this.filters = [];
      match = this.markup.match(VARIABLE);
      if (match != null) {
        this.name = match[1];
        filter_matches = markup.match(FILTERS);
        if (filter_matches != null) {
          filters = filter_matches[1].split('|');
          for (_i = 0, _len = filters.length; _i < _len; _i++) {
            filter = filters[_i];
            matches = filter.match(WORDS);
            if (matches != null) {
              name = matches[1];
              args = [];
              parts = (_ref = filter.match(FILTER_PARTS)) != null ? _ref : [];
              for (_j = 0, _len1 = parts.length; _j < _len1; _j++) {
                arg = parts[_j];
                cleaned = arg.match(FILTER_CLEANUP);
                if (cleaned != null) {
                  args.push(cleaned[1]);
                }
              }
              this.filters.push([name, args]);
            }
          }
        }
      }
    }

    Variable.prototype.render = function(context) {
      var args, name, output, _i, _len, _ref, _ref1;

      if (this.name == null) {
        return '';
      }
      output = context.get(this.name);
      _ref = this.filters;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        _ref1 = _ref[_i], name = _ref1[0], args = _ref1[1];
        args = arrayMap(args, function(arg) {
          return context.get(arg);
        });
        args.unshift(output);
        output = context.invoke(name, args);
      }
      return output;
    };

    return Variable;

  })();

  Liquid.Condition = (function() {
    function Condition(left, operator, right) {
      this.left = left;
      this.operator = operator;
      this.right = right;
      this.childRelation = null;
      this.childCondition = null;
      this.attachment = null;
    }

    Condition.prototype.evaluate = function(context) {
      var result;

      if (context == null) {
        context = new Liquid.Context();
      }
      result = this.interpretCondition(this.left, this.right, this.operator, context);
      switch (this.childRelation) {
        case 'or':
          return result || this.childCondition.evaluate(context);
        case 'and':
          return result && this.childCondition.evaluate(context);
        default:
          return result;
      }
    };

    Condition.prototype.or = function(condition) {
      this.childRelation = 'or';
      return this.childCondition = condition;
    };

    Condition.prototype.and = function(condition) {
      this.childRelation = 'and';
      return this.childCondition = condition;
    };

    Condition.prototype.attach = function(attachment) {
      return this.attachment = attachment;
    };

    Condition.prototype.isElse = false;

    Condition.prototype.interpretCondition = function(left, right, op, ctx) {
      if (op == null) {
        return ctx.get(left);
      }
      left = ctx.get(left);
      right = ctx.get(right);
      op = this.constructor.operators[op];
      if (op == null) {
        throw new Error("Unknown operator " + op);
      }
      return op(left, right);
    };

    Condition.prototype.toString = function() {
      return "<Condition " + this.left + " " + this.operator + " " + this.right + ">";
    };

    Condition.operators = {
      '==': function(l, r) {
        return l === r;
      },
      '=': function(l, r) {
        return l === r;
      },
      '!=': function(l, r) {
        return l !== r;
      },
      '<>': function(l, r) {
        return l !== r;
      },
      '<': function(l, r) {
        return l < r;
      },
      '>': function(l, r) {
        return l > r;
      },
      '<=': function(l, r) {
        return l <= r;
      },
      '>=': function(l, r) {
        return l >= r;
      },
      contains: function(l, r) {
        return arrayHasItem(l, r);
      },
      hasKey: function(l, r) {
        return objectHasKey(l, r);
      },
      hasValue: function(l, r) {
        return objectHasValue(l, r);
      }
    };

    return Condition;

  })();

  Liquid.ElseCondition = (function(_super) {
    __extends(ElseCondition, _super);

    function ElseCondition() {
      _ref = ElseCondition.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    ElseCondition.prototype.isElse = true;

    ElseCondition.prototype.evaluate = function() {
      return true;
    };

    ElseCondition.prototype.toString = function() {
      return "<ElseCondition>";
    };

    return ElseCondition;

  })(Liquid.Condition);

  Liquid.Template = (function() {
    var TOKENIZER;

    TOKENIZER = /(\{\%.*?\%\}|\{\{.*?\}\}?)/;

    function Template() {
      this.root = null;
      this.registers = {};
      this.assigns = {};
      this.errors = [];
      this.rethrowErrors = false;
    }

    Template.prototype.parse = function(src) {
      this.root = new Liquid.Document(this.constructor.tokenize(src));
      return this;
    };

    Template.prototype.render = function() {
      var args, context, results;

      if (this.root == null) {
        return '';
      }
      args = {
        ctx: arguments[0],
        filters: arguments[1],
        registers: arguments[2]
      };
      context = null;
      if (args.ctx instanceof Liquid.Context) {
        context = args.ctx;
        this.assigns = context.assigns;
        this.registers = context.registers;
      } else {
        if (args.ctx != null) {
          objectExtend(this.assigns, args.ctx);
        }
        if (args.registers != null) {
          objectExtend(this.registers, args.registers);
        }
        context = new Liquid.Context(this.assigns, this.registers, this.rethrowErrors);
      }
      if (args.filters != null) {
        context.addFilters(args.filters);
      }
      try {
        results = this.root.render(context).join('');
      } finally {
        this.errors = context.errors;
      }
      return results;
    };

    Template.prototype.renderWithErrors = function() {
      var oldErrorVal, results;

      oldErrorVal = this.rethrowErrors;
      this.rethrowErrors = true;
      results = this.render.apply(this, arguments);
      this.rethrowErrors = oldErrorVal;
      return results;
    };

    Template.tags = {};

    Template.registerTag = function(name, cls) {
      this.tags[name] = cls;
      return this;
    };

    Template.registerFilter = function(filters) {
      Liquid.Strainer.registerFilters(filters);
      return this;
    };

    Template.registerFilters = Template.registerFilter;

    Template.tokenize = function(src) {
      var tokens;

      tokens = src.split(TOKENIZER);
      if (tokens[0] === '') {
        tokens.shift();
      }
      return tokens;
    };

    Template.parse = function(src) {
      return new this().parse(src);
    };

    return Template;

  })();

  Liquid.Template.registerFilter({
    date: function(input, format, locale) {
      var date;

      date = input instanceof Date ? input : input === 'now' ? new Date() : new Date(input);
      if (!(date instanceof Date)) {
        date = new Date(Date.parse(input));
      }
      if (date instanceof Date) {
        return strftime(format, date, locale);
      } else {
        return input;
      }
    }
  });

  Liquid.Template.registerFilter({
    size: function(arr) {
      var _ref1;

      return (_ref1 = arr.length) != null ? _ref1 : 0;
    },
    join: function(arr, sep) {
      if (sep == null) {
        sep = ' ';
      }
      return arr.join(sep);
    },
    first: function(arr) {
      return arrayFirst(arr);
    },
    last: function(arr) {
      return arrayLast(arr);
    },
    sort: function(arr) {
      return arr.sort();
    },
    reverse: function(arr) {
      return arr.reverse();
    }
  });

  escape_str = function(input) {
    return input.toString().replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
  };

  truncate_words = function(input, words, string) {
    var l, wordlist;

    if (words == null) {
      words = '15';
    }
    if (string == null) {
      string = '...';
    }
    if (!((input != null) && input !== '')) {
      return '';
    }
    words = parseInt(words, 10);
    wordlist = input.toString().split(" ");
    l = Math.max(words, 0);
    if (wordlist.length > l) {
      return wordlist.slice(0, l).join(' ') + string;
    } else {
      return input;
    }
  };

  Liquid.Template.registerFilter({
    downcase: function(input) {
      return input.toString().toLowerCase();
    },
    upcase: function(input) {
      return input.toString().toUpperCase();
    },
    capitalize: function(input) {
      return stringCapitalize(input);
    },
    replace: function(input, string, replacement) {
      if (replacement == null) {
        replacement = '';
      }
      return input.toString().replace(new RegExp(string, 'g'), replacement);
    },
    replace_first: function(input, string, replacement) {
      if (replacement == null) {
        replacement = '';
      }
      return input.toString().replace(new RegExp(string, ""), replacement);
    },
    escape: escape_str,
    h: escape_str,
    truncate: function(input, length, string) {
      var seg;

      if (length == null) {
        length = 50;
      }
      if (string == null) {
        string = "...";
      }
      if (!((input != null) && input !== '')) {
        return '';
      }
      seg = input.slice(0, length);
      if (input.length > length) {
        return input.slice(0, length) + string;
      } else {
        return input;
      }
    },
    truncatewords: truncate_words,
    truncate_words: truncate_words,
    strip_html: function(input) {
      return input.toString().replace(/<.*?>/g, '');
    },
    strip_newlines: function(input) {
      return input.toString().replace(/\n/g, '');
    },
    newline_to_br: function(input) {
      return input.toString().replace(/\n/g, "<br/>\n");
    }
  });

  AssignTag = (function(_super) {
    var tagSyntax;

    __extends(AssignTag, _super);

    tagSyntax = /((?:\(?[\w\-\.\[\]]\)?)+)\s*=\s*((?:"[^"]+"|'[^']+'|[^\s,|]+)+)/;

    function AssignTag(tag, markup, tokens) {
      var parts, _;

      parts = markup.match(tagSyntax);
      if (parts == null) {
        throw new Error("Syntax error in 'assign' - Valid syntax: assign [var] = [source]");
      }
      _ = parts[0], this.to = parts[1], this.from = parts[2];
      AssignTag.__super__.constructor.call(this, tag, markup, tokens);
    }

    AssignTag.prototype.render = function(ctx) {
      arrayLast(ctx.scopes)[this.to] = ctx.get(this.from);
      return "";
    };

    return AssignTag;

  })(Liquid.Tag);

  Liquid.Template.registerTag('assign', AssignTag);

  CaptureTag = (function(_super) {
    var tagSyntax;

    __extends(CaptureTag, _super);

    tagSyntax = /(\w+)/;

    function CaptureTag(tagName, markup, tokens) {
      var parts;

      parts = markup.match(tagSyntax);
      if (parts == null) {
        throw "Syntax error in '" + tagName + "' - Valid syntax: capture [var]";
      }
      this.to = parts[1];
      CaptureTag.__super__.constructor.call(this, tagName, markup, tokens);
    }

    CaptureTag.prototype.render = function(context) {
      var output;

      output = CaptureTag.__super__.render.call(this, context);
      context.set(this.to, arrayFlatten([output]).join(''));
      return '';
    };

    return CaptureTag;

  })(Liquid.Block);

  CacheTag = (function(_super) {
    __extends(CacheTag, _super);

    function CacheTag() {
      _ref1 = CacheTag.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    CacheTag.prototype.render = function(context) {
      var output;

      output = CacheTag.__super__.render.call(this, context);
      arrayLast(context.scopes)[this.to] = arrayFlatten([output]).join('');
      return '';
    };

    return CacheTag;

  })(CaptureTag);

  Liquid.Template.registerTag('cache', CacheTag);

  Liquid.Template.registerTag('capture', CaptureTag);

  CommentTag = (function(_super) {
    __extends(CommentTag, _super);

    function CommentTag() {
      _ref2 = CommentTag.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    CommentTag.prototype.render = function() {
      return '';
    };

    return CommentTag;

  })(Liquid.Block);

  Liquid.Template.registerTag('comment', CommentTag);

}).call(this);
/*!
 * Cross-Browser Split 1.1.1
 * Copyright 2007-2012 Steven Levithan <stevenlevithan.com>
 * Available under the MIT License
 * ECMAScript compliant, uniform cross-browser split method
 */

/**
 * Splits a string into an array of strings using a regex or string separator. Matches of the
 * separator are not included in the result array. However, if `separator` is a regex that contains
 * capturing groups, backreferences are spliced into the result each time `separator` is matched.
 * Fixes browser bugs compared to the native `String.prototype.split` and can be used reliably
 * cross-browser.
 * @param {String} str String to split.
 * @param {RegExp|String} separator Regex or string to use for separating the string.
 * @param {Number} [limit] Maximum number of items to include in the result array.
 * @returns {Array} Array of substrings.
 * @example
 *
 * // Basic use
 * split('a b c d', ' ');
 * // -> ['a', 'b', 'c', 'd']
 *
 * // With limit
 * split('a b c d', ' ', 2);
 * // -> ['a', 'b']
 *
 * // Backreferences in result array
 * split('..word1 word2..', /([a-z]+)(\d+)/i);
 * // -> ['..', 'word', '1', ' ', 'word', '2', '..']
 */
var split;

// Avoid running twice; that would break the `nativeSplit` reference
split = split || function (undef) {

    var nativeSplit = String.prototype.split,
        compliantExecNpcg = /()??/.exec("")[1] === undef, // NPCG: nonparticipating capturing group
        self;

    self = function (str, separator, limit) {
        // If `separator` is not a regex, use `nativeSplit`
        if (Object.prototype.toString.call(separator) !== "[object RegExp]") {
            return nativeSplit.call(str, separator, limit);
        }
        var output = [],
            flags = (separator.ignoreCase ? "i" : "") +
                    (separator.multiline  ? "m" : "") +
                    (separator.extended   ? "x" : "") + // Proposed for ES6
                    (separator.sticky     ? "y" : ""), // Firefox 3+
            lastLastIndex = 0,
            // Make `global` and avoid `lastIndex` issues by working with a copy
            separator = new RegExp(separator.source, flags + "g"),
            separator2, match, lastIndex, lastLength;
        str += ""; // Type-convert
        if (!compliantExecNpcg) {
            // Doesn't need flags gy, but they don't hurt
            separator2 = new RegExp("^" + separator.source + "$(?!\\s)", flags);
        }
        /* Values for `limit`, per the spec:
         * If undefined: 4294967295 // Math.pow(2, 32) - 1
         * If 0, Infinity, or NaN: 0
         * If positive number: limit = Math.floor(limit); if (limit > 4294967295) limit -= 4294967296;
         * If negative number: 4294967296 - Math.floor(Math.abs(limit))
         * If other: Type-convert, then use the above rules
         */
        limit = limit === undef ?
            -1 >>> 0 : // Math.pow(2, 32) - 1
            limit >>> 0; // ToUint32(limit)
        while (match = separator.exec(str)) {
            // `separator.lastIndex` is not reliable cross-browser
            lastIndex = match.index + match[0].length;
            if (lastIndex > lastLastIndex) {
                output.push(str.slice(lastLastIndex, match.index));
                // Fix browsers whose `exec` methods don't consistently return `undefined` for
                // nonparticipating capturing groups
                if (!compliantExecNpcg && match.length > 1) {
                    match[0].replace(separator2, function () {
                        for (var i = 1; i < arguments.length - 2; i++) {
                            if (arguments[i] === undef) {
                                match[i] = undef;
                            }
                        }
                    });
                }
                if (match.length > 1 && match.index < str.length) {
                    Array.prototype.push.apply(output, match.slice(1));
                }
                lastLength = match[0].length;
                lastLastIndex = lastIndex;
                if (output.length >= limit) {
                    break;
                }
            }
            if (separator.lastIndex === match.index) {
                separator.lastIndex++; // Avoid an infinite loop
            }
        }
        if (lastLastIndex === str.length) {
            if (lastLength || !separator.test("")) {
                output.push("");
            }
        } else {
            output.push(str.slice(lastLastIndex));
        }
        return output.length > limit ? output.slice(0, limit) : output;
    };

    // For convenience
    String.prototype.split = function (separator, limit) {
        return self(this, separator, limit);
    };

    return self;

}();
//
// strftime
// github.com/samsonjs/strftime
// @_sjs
//
// Copyright 2010 - 2013 Sami Samhuri <sami@samhuri.net>
//
// MIT License
// http://sjs.mit-license.org
//

;(function() {

  //// Export the API
  var namespace;

  // CommonJS / Node module
  if (typeof module !== 'undefined') {
    namespace = module.exports = strftime;
  }

  // Browsers and other environments
  else {
    // Get the global object. Works in ES3, ES5, and ES5 strict mode.
    namespace = (function(){ return this || (1,eval)('this') }());
  }

  namespace.strftime = strftime;
  namespace.strftimeUTC = strftimeUTC;
  namespace.localizedStrftime = localizedStrftime;

  ////

  function words(s) { return (s || '').split(' '); }

  var DefaultLocale =
  { days: words('Sunday Monday Tuesday Wednesday Thursday Friday Saturday')
  , shortDays: words('Sun Mon Tue Wed Thu Fri Sat')
  , months: words('January February March April May June July August September October November December')
  , shortMonths: words('Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec')
  , AM: 'AM'
  , PM: 'PM'
  , am: 'am'
  , pm: 'pm'
  };

  function strftime(fmt, d, locale) {
    return _strftime(fmt, d, locale, false);
  }

  function strftimeUTC(fmt, d, locale) {
    return _strftime(fmt, d, locale, true);
  }

  function localizedStrftime(locale) {
    return function(fmt, d) {
      return strftime(fmt, d, locale);
    };
  }

  // locale is an object with the same structure as DefaultLocale
  function _strftime(fmt, d, locale, _useUTC) {
    // d and locale are optional so check if d is really the locale
    if (d && !quacksLikeDate(d)) {
      locale = d;
      d = undefined;
    }
    d = d || new Date();
    locale = locale || DefaultLocale;
    locale.formats = locale.formats || {};
    var msDelta = 0;
    if (_useUTC) {
      msDelta = (d.getTimezoneOffset() || 0) * 60000;
      d = new Date(d.getTime() + msDelta);
    }

    // Most of the specifiers supported by C's strftime, and some from Ruby.
    // Some other syntax extensions from Ruby are supported: %-, %_, and %0
    // to pad with nothing, space, or zero (respectively).
    return fmt.replace(/%([-_0]?.)/g, function(_, c) {
      var mod, padding;
      if (c.length == 2) {
        mod = c[0];
        // omit padding
        if (mod == '-') {
          padding = '';
        }
        // pad with space
        else if (mod == '_') {
          padding = ' ';
        }
        // pad with zero
        else if (mod == '0') {
          padding = '0';
        }
        else {
          // unrecognized, return the format
          return _;
        }
        c = c[1];
      }
      switch (c) {
        case 'A': return locale.days[d.getDay()];
        case 'a': return locale.shortDays[d.getDay()];
        case 'B': return locale.months[d.getMonth()];
        case 'b': return locale.shortMonths[d.getMonth()];
        case 'C': return pad(Math.floor(d.getFullYear() / 100), padding);
        case 'D': return _strftime(locale.formats.D || '%m/%d/%y', d, locale);
        case 'd': return pad(d.getDate(), padding);
        case 'e': return d.getDate();
        case 'F': return _strftime(locale.formats.F || '%Y-%m-%d', d, locale);
        case 'H': return pad(d.getHours(), padding);
        case 'h': return locale.shortMonths[d.getMonth()];
        case 'I': return pad(hours12(d), padding);
        case 'j':
          var y=new Date(d.getFullYear(), 0, 1);
          var day = Math.ceil((d.getTime() - y.getTime()) / (1000*60*60*24));
          return day;
        case 'k': return pad(d.getHours(), padding == null ? ' ' : padding);
        case 'L': return pad(Math.floor(d.getTime() % 1000), 3);
        case 'l': return pad(hours12(d), padding == null ? ' ' : padding);
        case 'M': return pad(d.getMinutes(), padding);
        case 'm': return pad(d.getMonth() + 1, padding);
        case 'n': return '\n';
        case 'P': return d.getHours() < 12 ? locale.am : locale.pm;
        case 'p': return d.getHours() < 12 ? locale.AM : locale.PM;
        case 'R': return _strftime(locale.formats.R || '%H:%M', d, locale);
        case 'r': return _strftime(locale.formats.r || '%I:%M:%S %p', d, locale);
        case 'S': return pad(d.getSeconds(), padding);
        case 's': return Math.floor((d.getTime() - msDelta) / 1000);
        case 'T': return _strftime(locale.formats.T || '%H:%M:%S', d, locale);
        case 't': return '\t';
        case 'U': return pad(weekNumber(d, 'sunday'), padding);
        case 'u':
          var day = d.getDay();
          return day == 0 ? 7 : day; // 1 - 7, Monday is first day of the week
        case 'v': return _strftime(locale.formats.v || '%e-%b-%Y', d, locale);
        case 'W': return pad(weekNumber(d, 'monday'), padding);
        case 'w': return d.getDay(); // 0 - 6, Sunday is first day of the week
        case 'Y': return d.getFullYear();
        case 'y':
          var y = String(d.getFullYear());
          return y.slice(y.length - 2);
        case 'Z':
          if (_useUTC) {
            return "GMT";
          }
          else {
            var tz = d.toString().match(/\((\w+)\)/);
            return tz && tz[1] || '';
          }
        case 'z':
          if (_useUTC) {
            return "+0000";
          }
          else {
            var off = d.getTimezoneOffset();
            return (off < 0 ? '+' : '-') + pad(Math.abs(off / 60)) + pad(off % 60);
          }
        default: return c;
      }
    });
  }

  RequiredDateMethods = ['getTime', 'getTimezoneOffset', 'getDay', 'getDate', 'getMonth', 'getFullYear', 'getYear', 'getHours', 'getMinutes', 'getSeconds'];
  function quacksLikeDate(x) {
    var i = 0
      , n = RequiredDateMethods.length
      ;
    for (i = 0; i < n; ++i) {
      if (typeof x[RequiredDateMethods[i]] != 'function') {
        return false;
      }
    }
    return true;
  }

  // Default padding is '0' and default length is 2, both are optional.
  function pad(n, padding, length) {
    // pad(n, <length>)
    if (typeof padding === 'number') {
      length = padding;
      padding = '0';
    }

    // Defaults handle pad(n) and pad(n, <padding>)
    if (padding == null) {
      padding = '0';
    }
    length = length || 2;

    var s = String(n);
    // padding may be an empty string, don't loop forever if it is
    if (padding) {
      while (s.length < length) s = padding + s;
    }
    return s;
  }

  function hours12(d) {
    var hour = d.getHours();
    if (hour == 0) hour = 12;
    else if (hour > 12) hour -= 12;
    return hour;
  }

  // firstWeekday: 'sunday' or 'monday', default is 'sunday'
  //
  // Pilfered & ported from Ruby's strftime implementation.
  function weekNumber(d, firstWeekday) {
    firstWeekday = firstWeekday || 'sunday';

    // This works by shifting the weekday back by one day if we
    // are treating Monday as the first day of the week.
    var wday = d.getDay();
    if (firstWeekday == 'monday') {
      if (wday == 0) // Sunday
        wday = 6;
      else
        wday--;
    }
    var firstDayOfYear = new Date(d.getFullYear(), 0, 1)
      , yday = (d - firstDayOfYear) / 86400000
      , weekNum = (yday + 7 - wday) / 7
      ;
    return Math.floor(weekNum);
  }

}());